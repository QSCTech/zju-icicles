# 图

## 定义

边（Edge）

顶点（Vertex）

度：相连边的个数，不同与树的子节点树（少 1）。

## 表示

二维数组：表示边的方向、权。

无向：使用单一数组，多重链表（共用存储，用多链串起每个元素）

有向：邻接链表，十字链表（共用存储，分别用两链串起出入）

关键信息在顶点（AOV，Activity On Vertex）

## Dijkstra

Dijkstra算法是一个贪心算法，那么我们可以通过数学归纳法证明其正确性，关键就是如何建立数学模型。Dijkstra算法的步骤是显然的，是简单的，我们只需要证明这个算法产生的路径就是最短的就可以了，于是模型就有了，很多书上都用open-set作为“外面”的点，将close-set作为加入到“里面”的点，那么我们就证明每通过Dijkstra算法加入到close-set的点到原点的距离就是到原点距离的最短距离，这样我们就证明了算法本身的正确性，因此开始用数学归纳法证明吧，当close-set中除了原点只有一个点的时候，这个点p离原点s的距离一定是最短的，因为如果s先到x再到p的距离比s直接到p还短，那么s到x会更短，算法就不会选中p而会选中x，与假设矛盾，这里已经证明了初始条件，下面开始归纳假设，设close-set中有k个点时，所有close-set中的k个点根据算法算出的距离都是最短的距离，那么我们考虑加入第k+1个点加入时的情形，只要能证明k+1个点按照算法加入进close-set从而算出的距离也是最短距离的话，那么问题得证，这个问题也是很好证明的，同样用反证法，假设不是靠算法加入的，那么路径中一定除了终点p之外还有一个点在open-set中，如果这样的话，根本就不可选中终点p而会选中那个经过的点，也是矛盾的，由此问题得证。在上面额证明中，所有在close-set中和p相连的点都会参与最后的最短距离竞争，因此就在它们当中选一条路径最为结果就是问题的答案，而这正是算法的行为。

## 最小生成树

n 节点连通且无回路：n-1 条边

Prim 算法（点扩展）：由某点开始扩展树，选取最小路径，类 Dijkstra

Kruskal 算法（边加入）：将边从小到大排序，每次取出最小边，不构成回路则放入。使用事先排序或堆。使用并查集优化环路判别

## 深度优先遍历

递归，访问所有未标记已访问的相邻顶点

遍历非连通图：对每个节点，若未标记已访问，调用深度优先遍历。可由此获得 Component 数

为获得唯一顺序，考试将使用图的具体表示进行考察

## 双连通问题

关键点（Articulation Point）：摘除后分为多个 Component

双连通图：无关键点

算法：。。。

## 欧拉回路问题

一笔画问题（边不重复）

欧拉遍历：不重复遍历所有边，要求图有两个节点度奇数，则从一奇数回到另一奇数

欧拉回路：不重复遍历所有边并回到起点，要求所有节点度为偶数。

其他：哈密顿回路（点不重复）

# 树和图

# 树

## 定义

连通无回路的图。

节点的度（Degree）：子节点的个数。

树的度：节点的度的最大值。

叶：度为零的节点。
总结点数为：n0+n1+n2+n3,又因为除了根结点外，其他结点均为孩子结点，而孩子结点可有分支数得到，
总结点数故也等于1+0*n0+1*n1+2*n2+3*n3;所以可得
n0=1+n2+2n3=2+2*2=6 

There exists a binary tree with 2016 nodes in total, and with 16 nodes having only one child.
n0+n1+n2 =2016=1+0*n0+1*n1+2*n2 
n0=1+n2 n₀+n₁+n₂=2016
⇨n₂+1+16+n₂=2016
⇨2n₂=1999
n₂除不尽，所以答案错误。
It is always possible to represent a tree by a one-dimensional integer array.  √  前序遍历，中序遍历这些不就可以把一棵树变成一个数组

## 表示

* Children

* FirstChild - NextSibling

## 二叉树
一般树转换二叉树：
1）将每一个结点与他的兄弟结点之间连一条线。
2）对每一个双亲结点，只保留它与第一个子结点的连线，删除与其余结点的连线。
3）整理，左右摆齐。
利用 FirstChild - NextSibling 表示方法，可以将兄弟节点均变为右侧儿子节点，从而将任何树转为二叉树。

就是每个点的左儿子是它的第一个儿子，右儿子是它从左往右数的第一个兄弟

![](https://img-blog.csdn.net/20180713160942112?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV2ZXJfZHJlYW1z/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

二叉树转换一般树（相反）：
      1）若一个结点是其父结点的左结点，则将此结点的右结点，右结点的右结点。。。都与其父结点相连线。

 2）删除原二叉树所有父结点与右结点的连线。

**遍历方式**：

* 深度优先遍历，堆栈（递归调用栈）：

    （前中后以值的遍历顺序为基准）

    * 前序（Pre-order）遍历：值左右（前缀表达式）

    * 中序（In-order）遍历：左值右（中缀表达式）

    * 后序（Post-order）遍历：左右值（后缀表达式）

    已知前/后序和中序遍历序列，则可以知道树的结构.后序最后一个是根, 前序第一个是根.
中序二叉树 = 后序普通树

* 广度优先遍历，队列：

    * 层次遍历（Level-order）

性质：

* 第 k 层至多有 2 ^ (k - 1) 个节点；k 层树至多有 2 ^ k - 1 个节点。

* 叶节点数量 = 双儿子节点数量。

### 线索二叉树（Threaded Binary Tree）
二叉树的遍历本质上是将一个复杂的非线性结构转换为线性结构，使每个节点都有了唯一前驱和后继（第一个节点无前驱，最后一个节点无后继）。对于二叉树的一个节点，查找其左右子女是方便的，其前驱后继只有在遍历中得到。为了容易找到前驱和后继，有两种方法。一是在节点结构中增加向前和向后的指针，这种方法增加了存储开销，不可取；二是利用二叉树的空链指针。
所有应该为空的右孩子指针指向该节点在中序序列中的*后继*，所有应该为空的左孩子指针指向该节点的中序序列的*前驱*。各使用一个布尔值标识此指针是否为线索。

访问策略为访问右线索，或右树最左下节点。
https://blog.csdn.net/demi_hu/article/details/70183267
中序线索化二叉树：若节点的leftTag = 0, leftchild指向前驱；

否则，该节点的前驱是以该节点为根的左子树上按中序遍历的最后一个节点。
若rightTag= 0， rightchild指向后继；

否则，该节点的后继是以该节点为根的右子树上按中序遍历的第一个节点。
在线索化的时候有一个比较难理解的点，比如上图中，我们已经将3节点的左孩子线索化，现在要判断3的右孩子是否为空，如果为空应该将右孩子指针指向谁？就如我只知道我昨天几点起床，却不知道明天几点起床。虽然我今天不知道明天几点起床，但我可以在后天知道我明天几点起床。这里是同样的道理，线索化3右孩子时，我们不知道右孩子应该指向谁，我们可以先什么都不做，等到递归到2的时候，我们知道3的右孩子应该指向2了，这时再将3的右孩子指向2。

### 完全二叉树（Complete Binary Tree）

除最后一层外其他层均充满。没有度为1的结点, n1 = 0 

### 二叉查找树（Binary Search Tree，BST）

中序遍历时为有序序列。

二叉搜索树.:

*左儿子有**6**个结点，则根的值为数组中第**7**大的值*

插入结点:



删除节点：

查找右树最小值，右树由右树最小值替代，删除右树中最小值。

优化：

* AVL：层差不超过 1
* 多叉树

下列二叉树中，可能成为折半查找判定树（不含外部结点）的是（）

https://blog.csdn.net/qq_41754065/article/details/106590844?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare

什么是尾递归？ 

如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。

斐波那契,二叉树的高度是 n - 1，由我们的基础知识可以知道，一个高度为k的二叉树最多可以由 2^k - 1个叶子节点，也就是递归过程函数调用的次数，所以时间复杂度为 O(2^n)，而空间复杂度就是树的高度 S(n)

 

一棵有 n 个内结点的红黑树的高度至多是 2log(n+1)，

 

查找一个元素所需要的时间最坏是2lgN，插入一个元素最坏情况所需要的时间是2lgN，查找命中所需要的平均时间是lgN，插入一个元素所需要的平均时间也是lgN.



**若完全二叉树的节点个数为2N-1，则叶节点个数为（）**
  A）N-1    B）2×N    C）2N-1    D）2N

答案: D
  证明：因为结点拥有的子树数为结点的度,二叉树中所有结点的度数均不大于2，所以结点总数(记为n)应等于0度结点数、1度结点(记为n1)和2度结点数之和：     n=no+n1+n2(式子1)　
  另一方面，1度结点有一个孩子，2度结点有两个孩子，故二叉树中孩子结点总数是：n1+2*n2 　 　
  树中只有根结点不是任何结点的孩子，故二叉树中的结点总数又可表示为：             n=n1+2n2+1 (式子2)　　
  由式子1和式子2得到： no=n2+1

  **完全二叉树的n1=0** 所以，
$$
n = n0 + n0 - 1 + 1 = 2n0
$$

二叉树的数学性质
n0 = n2 + 1  n2是 degree =2 的node数量。 n0是叶结点数量。

prove：
n = n0 + n1+ n2  =124
n =B+1 ， B 是分支数量。 
B = n1+ 2 *n2 
根据上面三条可以得到。

BST二叉搜索树。
（1） 每个node 有一个整数key，key是distinct 独特的。
（2） 任何左子树都比根节点小。
（3 比根节点 大的在根节点右边
（4  

```cpp
Position Find (ElementType X,Search Tree T) ： 
if（T == null）
 return null;
if(x < T->Element) 
 return Find(X,T->left);
else
 if(x > T->Element)
  return Find(X,T->Right);
 else
  return T;
} T(N) =O (depth)
```


怎么计算时间复杂度？
子结点接近 1/2 结点 ，有1/2概率在最后一层
degree 1 约1/4结点， 

插入：

```cpp
if（T == null）{
 T = malloc(sizeof(struct TreeNode));
 T ->Element = X;
 T->left = T->right =null;
 }
 else
  if(X< T->element)
   T->left = Insert(X,T->left);
 	else
 	 if(X> T->element)
   	T->right = Insert(X,T->right);
return T; 	 
}
```


难点： delete a degree 2
无孩结点 直接删除。
单孩结点，让父节点指针指向单孩。
双孩结点， 左子树最大的来替代。然后递归Delete（左子树）。 把左子树最大的删除，把复杂问题简单化，                                      

二叉搜索树
左子树每个结点都不大于root， 
右子树每个结点都不小于root，
查询复杂度：  查询结点比较次数为depth +1
构造复杂度和查询复杂度相同                   


完全二叉树
除了最后一层外， 别的层都是满的， 最后一层集中在最左边。(notice : not as same as full binary tree ) level－order遍历时，搜索到空节点就遍历完树了。    
度为1 的节点个数要么1个，要么0个，
2n0 = 总数+1 － n1
124 n1 =1 ， n0 = 总数/2 
最大堆
                                     
最小堆
删除最小，
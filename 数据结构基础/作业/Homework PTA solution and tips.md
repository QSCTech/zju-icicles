## 只写解法和注意点,代码网上有很多.

## 1.Evaluate Postfix Expression

Write a program to evaluate a postfix expression.  You only have to handle four kinds of operators: +, -, x, and /.

解法:

//如果遇到数字,用另一个数组记录这个数字,直到遇到下一个空格,就把数组里的东西转化为数字,并且清空数组.//把b截止使用atof函数 

//如果遇到 - 或+ , 如果下一个是数字,那就数组记录,如果下一个是空格,那就pop两个,加起来或减去. 

//如果遇到*或/,那就pop两个,如果top<1,那就不够,返回error,如果/0,那也error

//i++继续遍历,直到 '\0'

//如果 top为0, 那就输出数字, 否则就错误. 

**注意**: top是指向栈顶,还是栈顶上方一个空地址.

## 2.Pop Sequence

// m 从0 到6,是序列的循环变量,  m ==7时,序列就结束了,m is 序列的index, v从1到7, 是入栈的元素

​	// 首先, 保存输入序列,第一个data和1不同,那1入栈, 要入栈的元素2小于序列,那就继续入栈,直到大于序列.,如果栈满了还是和第一个不同,那就error

​	// 如果栈没满,peek = datam,那就pop出栈, 第二个和stack[top]相同,继续出栈,不相同,继续入栈,

​	// 直到判断到第N个,出栈成功,那就right.如果栈顶大于序列,那就error.中间栈满了或者top==-1了,那就error.

注意点: 

1. // st.peek 放在后面否则会有emptystack异常. 
2. System.out.println("判断序列data["+m); 来调试

判断题:

For a sequentially stored linear list of length *N*, the time complexities for deleting the first element and inserting the last element are *O*(1) and *O*(*N*), respectively.

答案是False

## 3.Isomorphic 同构树

为空 return 1. 

 是叶了,返回1. 

 否则判断子树 

给根结点, A左 =B左 && A右是否为B右. 如果是,返回1.如果不是返回0.

判断A右  =B左,  &&如果是,A左是否为B右

 A右  !=B左,返回0 ;

 如果分别只有一个,判断是否相等,是的话,返回1. 一个为两个一个为一个,返回0. (包括在上面的==情况) 

如果不等于, 0

## 4.Zigzagtree

二叉树zigzag遍历	

首先建立二叉树

/*build a Tree from postorder and inorder

​	后序遍历的最后一个数为根结点，根据这个根结点来划分中序遍历，将其分为左子树和右子树

​	②确定左右子树的中序遍历和后遍历中的界限,中序从0 - root为左, root+1 到最后为右. 后序0-root为左,root到postOrder.length-1 为右.

​	③递归调用

​	*/

然后zigzag,可以先简单用queue层次遍历,再加上stack来zigzag遍历.

/*要进行层次遍历，需要建立一个循环队列。先将二叉树头结点入队列，然后出队列，访问该结点，如果它有左子树

​	则将左子树的根结点入队:如果它有右子树，则将右子树的根结点入队。然后出队列，对出队结点访问，如此反复，直到队列为空为止。

​	z字形层次遍历是对层次遍历加上了一个限制条件（即相邻层，从左到右的遍历顺序相反），

​	我们取queue大小,就是上一层的结点数. for循环把这一层都加入进去,如果奇数层就第一个结点开始(因为上一层是偶数)先加右再加左.

​	如果偶数层就最后结点开始(因为上一层是奇数)先加左再加右.

​	一层结束深度增加,同时用一个栈,因为遍历下一层的数据 和输出这一层的数据  是刚好相反的..

​	data  arraylist是因为他最后不要空格, 所以全部保存了再输出. 不然stack其实就有正确答案了,最后多一个空格.

​	*/

## 5  judge red-black tree

[1135 Is It A Red-Black Tree(判断是否是红黑树)www.cnblogs.com![图标](https://pic3.zhimg.com/v2-a94ddbf603738f51d17d7732d322562e_180x120.jpg)](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/keep23456/p/12507390.html)

首先我们根据前序表达式建立二叉树。然后判断是否为红黑树.

**如何判断二叉树。根据题目描述的性质，我们要进行如下三点判断** 
**1、根节点是否为正数** 
**2、节点为负数，节点的孩子是否为正数（这里判断当前节点的左右孩子是否为正数）** 
**3、从任一节点到叶子节点所有路径拥有相同的黑色节点** 

**此题包括二叉树的基本操作：BST建树、后序遍历求树高、先序遍历。**

**对于属性4，我使用递归，首先判断根，如果根为空，则返回正确，如果根为负，则判断左右值，如果根为正，则判断左子树和 正确的子树。**

​      **对于属性5，判断左路径和右路径的高度。 如果高度相同，则将判断两个子树。 如果它们不相同，那将是错误的。 查找高度的功能（如果为黑色，则为+1）。 注意，当判断发现高度的函数为空时，则无需写left == null或right == null判断，无需编写四种情况。**

我自己设计一些样例,发现不对,因为不是二叉树,或者不是红黑树,前序遍历不能确定一颗二叉树,.

改写成C，那就 一个是没有bool类型和max函数，一个是scanf需要占位符\n和&i，而不是nextint。

## 6 Percolate Up and Down

题目其实不难, 但是还是写了好久, 有一个错误, 每个值都要思考,写多了还是挺费脑子的.

//  最小堆的插入维护和删除维护 不断比较交换儿子与父亲的值。直到p小于0或者子节点大于父节点. 

void PercolateUp( int p, PriorityQueue H ){ 



//已经把叶节点存到【1】了 

//调整的过程是不断比较父亲与儿子的值，这里左右儿子都要比较，如果发现父节点大于子节点，父节点就下去. 

void PercolateDown( int p, PriorityQueue H ){



## 7.并查集**File Transfer**

union by height   depth at most log2N+1

union by size   size用负数表示 ， 结点深度不会超过logN,

初始化：  把所有都设为－1，从 1开始设置，方便对应

union：  先找到根，然后数量相加，小的指向大的根。

大的根 + 小的根  = 总数量

  －3+ －2

find  如果是根（s【x】是负数），就返回x， 否则就去寻找根，还可以路径压缩。 return  s【x】 = Find（s【x】）



## 8.Bonus-2Social Clusters

int course[1010] ={ 0 };// at most 1000 hobbies init 

/*0. 每个社交圈的结点号是人的编号，而不是课程。课程是用来判断是否处在一个社交圈的。

\1. course[t]表示任意一个喜欢t活动的人的编号。

if当前的课程t，之前并没有人喜欢过，

then : course[t] = i，i为喜欢course[t]当前人的编号

例如1号喜欢3号活动，那就course【3】 = 1； 

\2. findFather(course[t])就是喜欢这个活动的人所处的社交圈子的根结点，

if 当前的课程t，之前有人喜欢过

then 合并根结点和当前人的编号的结点i。即Union(i, findFather(course[t]))，把它们处在同一个社交圈子里面



then // 输出总共几个簇,然后每个簇多少人. 

 再遍历一遍每个人，看看他们分属于那个集合，并给相应集合的人数+1

\3. isRoot[i]表示编号i的人是不是它自己社交圈子的根结点，

如果等于0表示不是根结点，如果不等于0，每次标记isRoot[findFather(i)]++，那

么isRoot保存的就是如果当前是根结点，那么这个社交圈里面的总人数

\4. isRoot中不为0的编号的个数cnt就是社交圈圈子的个数

最后遍历一遍看每个人是否 

\5. 把isRoot从大到小排列，输出前cnt个，就是社交圈人数的从大到小的输出顺序

*/

## 9. **Uniqueness of MST** 

    //解题思路：Kruskal最小生成树算法。首先关于最小生成树是否唯一，存在不唯一的情况即为有两个（及以上）权值相同的边,且最终的最小生成树只需要使用其中任意一个边，此时最小生成树不唯一。
    这里要采用之前的union和find 并查集
    用i遍历每一条边, j来看看i后面有几个重复边. 
    // 可以想到对于权值相同的一串边，先判断当前是否能作为最小生成树的边,如果不在一个set就可以.（用isTreeEdge标记），
    //然后k从i到j遍历, 将能够作为最小生成树的边依次加入已经生成的最小树中，用set union 合并连通分量,
    若出现某个边由于前面相同权值边的影响而不能加入最小树，此时说明最小生成树不唯一flag = false。
    // 而对于连通分量的求解，在求最小生成树的时候，每次加入一个新边的时候记一下数，最后用顶点数-该数即为连通分量的值。
```cpp
int UFfind(int x,UFset U){
    if(x == U->father[x])
        return x; // 如果她是树顶,就直接返回
    int i,j = x ;
    j = UFfind(U->father[x],U); // find the root
    while(j!= x){
        i = U->father[x];  // save the father of x
        U->father[x] = j; // x father point root
        x = i ; // next
    }
    //int a = UFfind(U->father[x],U); // 找到树顶
    //U->father[x] = a;   //然后把x的位置指向树顶. 没有路径压缩
    return j;
}
```

## 10.**Universal Travel Sites**

/*
本题是PAT上顶级1003，考察的知识点其实只有一个，最大流问题。vector定义时出现error C2065: “q”: 未声明的标识符 复制过来的时候,要把unix的RF变成window的CRLF.
用基于广度优先搜索的Edmonds-Karp算法求解。题目意思就是说求解最多能从地球站发送出去的最大人数，
在到达目的星球（MAR）上途径每一个行星（不包括MAR）上都没有收留多余游客的能力，到达的游客必须运送出去。
那么可以将EAR视为源点s，MAR视为汇点，是一个单源点单汇点的最大流问题
*/

/*
1. 首先把所有残余网络初始化为0,广度优先遍历查找从源点到达汇点的增广路
然后定义一个数组 a,a[i]代表从源点到i的最大流通量，即每次源点开始搜索，
最后的a[n]就是从源点到汇点的最大流通量，
 首先把source 入队, source 广度优先搜索, 先遍历从source出发的第一条边.
 起点的残量置为无穷大
2.遍历x节点的每一条边.如果当前边的终点的残量为0且容量大于流量,
那么更新最短路上到达结点p[i]的边在edges数组中的序号, p中记录终点在graph中的序号
 更新源点到该终点的残量, 再把终点压入队列继续判断从这个点出发的所有边,
 直到终点的残量不为零或者没有终点在队列中.
 3.一次搜索结束后, 源点到终点的残量a[t]为零，表示不存在增广路了，跳出外层死循环
 否则从汇点向前遍历增广路经，更新每条增广路的流量, p[u]偶数变奇数?奇数变偶数?
 flow记录最大流量
 4. 继续循环搜索, 再把将源点到达每个结点的残量初始化为0,再把source push进去.
在每一次搜索完成之后，如果a[n]==0，说明已经没有剩余可以流通的量了，then break and 直接return.
 */

```cpp
  while(1){
        //init the augmenting path
        for(int i = 0;i < 1005;i++){
            ap[i] = 0;
        }
        queue<int>q;  //广度优先遍历查找从源点到达汇点的增广路
        q.emplace(s);      //from source we begin search
        ap[s]  = MAX;  // 源点到自己的残量 = max
        while(!q.empty()){
            int v1 = q.front(); //vector 1 = source //遍历以队列第一个元素为起点的边
       //     cout<< "v1 = "<<v1<<endl;
            q.pop();
            // graph[s] 是一个vector,  vector里面的数字表示v1连着的一些vertex; 我们把每个vertex取出来判断一下.
            for(int i:graph[v1]){//遍历以x为起点的边 for (int j:i) { //这里i 是数组，j不是下标了，j是来接受每一个数组i遍历出来的值的。
                Edge &e = edges[i];
                if (ap[e.to] == 0 && e.cap > e.flow) {  //如果当前边的终点的残量为0且边的容量大于流量, 说明这个新的边可以增大他的残量.
                    gp[e.to] = i ;   // i is the number in graph 记录到达该终点的边的编号
                    ap[e.to] = min(ap[v1], e.cap - e.flow) ;  //更新源点到该终点的残量, 是原点到v1距离这一段路径流量和容量-流量残余流量的较小值
                    q.emplace(e.to);        //把终点压入队列,继续判断从这个点出发的所有边,   //     直到终点的残量不为零或者没有终点在队列中.
          //          cout << i << "= i  edge[i] = " << e.to << "ap[i]=" << ap[i] << endl;
                }
            }
            if(ap[t])//终点的残量不为零，跳出循环
                break;
        }
        //清空了队列之后,再判断
        //ap数组表示源点到结点a[i]的残量 在每一次搜索完成之后，如果==0，说明已经没有剩余可以流通的量了，直接跳出外层死循环 then return
        if(!ap[t])//源点到终点的残量为零，表示不存在增广路了，跳出外层死循环
            break;
        //否则, 往前找,更新每一个边的流量和反流量
        //其实就是如果是偶数变奇数?奇数变偶数?
        for(int i = t;i != s; i = edges[gp[i]].from){
            edges[gp[i]].flow += ap[t];
            // this process can update reversal flow
            edges[(gp[i] % 2 == 0 ? gp[i] + 1 : gp[i] - 1)].flow -= ap[t];
        }
        flow += ap[t];
        //4. 继续循环搜索, 再把将源点到达每个结点的残量初始化为0,再把source push进去,
    }
```

/* insert函数, 一个个插入边，起点为from，终点是to，容量为cap ,
首先找找这个边在不在无序map, 如果不在 ,那就insert一个 , 通过tran的size,就可以获得他的大小
then , we could use creator 构造函数, 在edges中创建边.  同时在 graph图中插入边,以及初始化一个反向边.
insertEdge
 */

## 11.**Hamiltonian Cycle**

```cpp
/* require contains every vertex 顶点, 由指定的起点前往指定的终点，途中经过所有其他节点且只经过一次*/   
//将每次问的点存在一个vector里面，也插入set中，这样可以用set去重，因为首尾是相同的，
    //输入完成后判断set大小是否和n相同且输入的点-1是否和n相同，且首尾是否相同，如果有一点不满足，就使flag1位false
    //for遍历每两个邻接点，如果两个邻接点没有通路，flag2设为false
    //两个flag都为true就输出no
    //each describes an edge in the format Vertex1 Vertex2, where the vertices are numbered from 1 to N
```



## 12.最短路径Dijkstra’s Algorithm 

S是一个集合， 包括了原点s和所有已经发现的路径。

走U1过路更短，那就更新distance [ u2 ] = distance [ u1 ] + length(< u1, u2>).

V = smallest unknwn distance vertex;

T = O( |V|^2 + |E| )

Distance 距离数组

 static vis[1001]  

 query[1001];查询数组

 G[1001][1001] 图table

bool Dijkstra(int root){

For( 遍历每一个节点)

原点到原点的距离为0

如果原点到j的路径距离比min小,而且没有遍历过这个点, 那就更新min.

把每个点记录完了, 开始查询.

如果查询的节点query[i]到原点的距离是min,，则以 query 当前点为中介 更新邻接点距原点的距离

不符合，说明此时不应当以 query 当前点为中介继续 Dijkstra，即此 query 非所要求的 Dijkstra sequence，返回 false

更新邻接点距原点的距离的方法是:

1/这个点已经查过了. 可以用 0 和1来标记, 1 表示记过了 static vis[1001] 

2/ 遍历每一个节点

 并且到有这条边 &&如果他到原点距离> 他到查询节点+查询节点到原点距离,&&没有遍历过这个点&&

那就更新 这个节点到原点的距离.

/利用for循环更新节点. 时间复杂度V^2  .

改进方法: 遍历和他相连的节点,

·    [整体模板还是用 Dijkstra](https://www.cnblogs.com/whale90830/p/11493567.html)，每次循环检查 query 的一位

·    查 当前距离原点最近 的 未访问点 与原点的距离

·    看 与当前位的 query 中的点 到原点的距离是否符合

·    若符合，则以 query 当前点为中介 更新邻接点距原点的距离

·    若不符合，说明此时不应当以 query 当前点为中介继续 Dijkstra，即此 query 非所要求的 Dijkstra sequence，返回 false

　由于此题还未上PAT官网题库，故没有测试集，仅仅是通过了样例，若发现错误，感谢留言指正。

Solution：

　　这道题不难，首先针对每个咨询，都对其出发点进行Dijkstra，然后判断询问的数组顺序是不是从小距离到大距离的，是的话那么就是Dijstra了，否则不是。

　　当然也可以在Dijstra的过程中直接判断，即每次选中的中间节点的最短距离是不是满足给出数组的那个节点，是的话继续。否则直接false

## 13.The World's Richest

难点在于查询的处理，我暴力写了一发在第二个测试点成功超时了，参考了PAT笔记，首先根据每次查询人数不会超过100对总体进行一个预处理，即把每个年龄的前100名放到另一个结构体中，这样只需要对总体进行一次排序，然后循环在新的结构体中查询即可。

不能每次都排序， 

·    所以先把所有的人按照财富值排序，建立1个数组标记每个年龄段拥有的人的数量，遍历数组并统计相应年龄的人数，当前年龄人数不超过100压入新的数组。即只取每个年龄前100名

这样你第一次100000十万，之后查一次不用全部，最多200*100 ，减小到20%

## 14.**Arrangement of Computation Tasks**

 首先把每个服务器排好放在map中,根据时 ,然后分, 然后秒 ,mapsort每个服务器
 然后放在set中. map就是为了整理每一个服务器.
事实上在set中不需要区分服务器name, 
然后再把服务器开始的时间排好. 因为第一个服务器的时间保证不会是自己下一个重复.
你要找最长,那就先看最早开始的时间it, 
how to process the itnext结束早于it,开始晚于it? directly add in vector
how to process the itnext结束晚于it,开始晚于it? link them
具体实现是:
如果it 包含itnext, 那就itnext加入到block中.然后itnext++;
直到没有包含,看下一个服务器有没有在it结束之前开始,
 如果有, 说明itnext连着it, 那就temptime+= itnextstat-itstat.
然后it= itnext,itnext++;继续遍历,下一个服务器有没有在it结束之前开始, 直到没有服务器在it结束前开始. 
最后如果没有连着, 那就 temptime +=it的长度.再加入到vector中

算法应该是nlogn的 

问题, 遍历每一个吗? 怎么遍历?
如果遍历每一个, 那很可能就重复了, 因为link的后面重复计算了. 所以必须移动it.

不需要每次query都遍历, 只需要遍历一次, 把它分成块, 然后和每一块比较即可.
最大的也不用单独算了, 节省了16行代码

如果背包问题的话,序列法. 
 *把序列加起来.然后重复的, 放在第二排, 注意重叠部分两排都有
那么,怎么判断重复呢? 如果b开始<a开始的时间< b结束 就是重复.
还有重复的, 放在第三排.
然后判断, 就第一排长度 - 这个, 第二排长度-这个

这题不用这么麻烦重叠起来.

时间片分配算法

 

在大学的计算中心里，有大量的服务器在一天的不同时间运行。现在有了所有可用的服务器信息，您应该告诉您可以运行的最长计算任务，并找到给定计算任务的有效开始时间总量（如果该任务是可运行的）。我们假设一个任务只能连续运行以完成它的所有计算，这意味着您不能停止它并重新启动它以继续。我们还假设一个计算任务可以在任何特定的时间从一个服务器切换到另一个服务器，而不需要任何代价，前提是两个服务器都是活动的。

每个输入文件包含一个测试用例。每种情况以两个正整数N（≤2×10）开

），服务器记录数，K（≤8×10））查询数。然后N行，每行给出一个记录，格式如下

服务器号hh:mm:ss

其中server_number是由7个英文小写字母或数字组成的字符串；hh:mm:ss表示一天中的时间点小时：分钟：第二，最早时间为00:00:00，最晚为23:59:59。

请注意，所有时间都将在一天之内。对于同一台服务器，每个开始记录与一个停止记录（按时间顺序排列）成对出现。使用24小时时钟记录时间。

接下来是K行查询，每个查询以hh:mm:ss格式给出特定计算任务的非零持续时间，这是完成任务所需的运行时间。

Hard题， 执行任务，

```
12 7
jh007bd 18:00:01  服务器记录数， 顺序不一定。 这个不难，排序一下就知道了。
zd00001 11:30:08
db8888a 13:00:00
za3q625 23:59:50
za133ch 13:00:00
zd00001 04:09:59
za3q625 11:42:01
za3q625 06:30:50
za3q625 23:55:00
za133ch 17:11:22
jh007bd 23:07:01
db8888a 11:35:50
08:30:01 // 持续8个小时，
12:23:42
05:10:00
04:11:21
00:04:10
05:06:59
00:05:11
 
31801 总共可以运行8.8336111 时
1201  选择权很小， 最多改变0.3336111 时
0  没有选择权， 安排完毕
132023.6672222 时
200635.5730556 时
6459764597 秒=17.9436111 时
1338//3.7180556 
64373  // 17.8813889 时
```

 给出服务器记录， queries请求。

给出最长可以run的时间，

对于每个测试用例，输出的第一行应该给出可以运行的最长计算任务（以秒为单位）。然后，对于每个查询，在一行中输出开始给定计算任务的有效时间点的总数。 也就是每个任务可以开始的时间点有多大的选择权。

 

 